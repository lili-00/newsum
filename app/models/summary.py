import logging
from datetime import datetime
from typing import Optional, List

from pydantic import BaseModel, AnyUrl, Field, validator, ConfigDict

logger = logging.getLogger(__name__)

# --- Model for Input Processing & Validation ---
class ArticleForProcessing(BaseModel):
    """
    Pydantic model used internally for validating and processing article data
    received from the external source, including parsing the pubDate string.
    """
    # Core Article Fields from source API data
    article_id: str                     # Original ID from NewsData.io
    title: Optional[str] = None
    reference_url: Optional[AnyUrl] = None # Validates as a URL string
    description: Optional[str] = None
    keywords: Optional[List[str]] = None # List of keyword strings or None
    source_name: Optional[str] = None

    # Field containing the original publication date string from the API
    # We will parse this into publication_date using a validator
    pubDate_str: Optional[str] = Field(None, alias="pubDate") # Alias to match input dict key

    # Generated Fields
    summary: Optional[str] = None           # Summary text generated by Gemini
    summary_generated_at: Optional[datetime] = None # Timestamp when summary was generated

    # Field to hold the parsed publication date (populated by validator)
    # This name aligns better with the SQLAlchemy model field 'publication_date'
    publication_date: Optional[datetime] = None

    @validator('publication_date', pre=True, always=True)
    def parse_pubdate(cls, v, values):
        """
        Parses the pubDate string from the input data (values['pubDate_str'])
        into the publication_date datetime field.
        'always=True' ensures this runs even if publication_date isn't explicitly provided.
        'pre=True' ensures it runs before other validation on publication_date.
        """
        pubdate_string = values.get('pubDate_str') # Get value using alias 'pubDate'
        if isinstance(pubdate_string, str):
            try:
                # Adjust format if necessary based on actual string format from API
                # Example format: "2025-04-16 13:26:00"
                # Assumes UTC if no timezone info is in the string
                parsed_dt = datetime.strptime(pubdate_string, "%Y-%m-%d %H:%M:%S")
                # Optionally make it timezone-aware (assuming UTC if not specified)
                # parsed_dt = parsed_dt.replace(tzinfo=timezone.utc)
                return parsed_dt
            except ValueError as e:
                logger.warning(f"Could not parse pubDate string '{pubdate_string}': {e}. Setting publication_date to None.")
                return None
        # If pubDate_str is None or not a string, return None for publication_date
        return None

    model_config = ConfigDict(
        # Allows Pydantic to work with ORM objects if needed (e.g., reading from DB)
        orm_mode = True,
        from_attributes = True,
        # Allows using 'pubDate' alias during model initialization
        allow_population_by_field_name = True,
        # Optional: Makes sure aliases are used when exporting the model
        # by_alias = True
    )

# --- Model for API Response --- 
class ArticleResponse(BaseModel):
    """
    Pydantic model specifically for the API response when returning article data.
    Reads attributes directly from the SQLAlchemy ArticleRecord model.
    """
    article_id: str
    title: Optional[str] = None
    reference_url: Optional[AnyUrl] = None
    description: Optional[str] = None
    keywords: Optional[List[str]] = None
    source_name: Optional[str] = None
    summary: Optional[str] = None
    summary_generated_at: Optional[datetime] = None
    publication_date: Optional[datetime] = None # Field directly mapped from DB

    model_config = ConfigDict(
        from_attributes = True # Reads directly from ORM object attributes
    )
